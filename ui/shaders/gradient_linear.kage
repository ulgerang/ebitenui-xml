//kage:unit pixels

// Linear gradient shader for ebitenui-xml.
//
// Computes the gradient position t = GradA*dstPos.x + GradB*dstPos.y + GradC
// and samples a 1D lookup texture (imageSrc0) with linear interpolation.
//
// The CPU precomputes GradA, GradB, GradC so that dstPos (which includes the
// GeoM translation) maps directly to t âˆˆ [0, 1].

package main

// GradA is cosA / dotRange (x component of gradient direction, normalised).
var GradA float

// GradB is sinA / dotRange (y component of gradient direction, normalised).
var GradB float

// GradC is the bias term that accounts for center offset and GeoM translation:
//   -(hw*cosA + hh*sinA + minDot) / dotRange - GradA*r.X - GradB*r.Y
var GradC float

// Fragment computes the output colour for each pixel of the gradient rectangle.
func Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {
	// Compute normalised gradient position from destination coordinates.
	t := GradA*dstPos.x + GradB*dstPos.y + GradC
	t = clamp(t, 0.0, 1.0)

	// Sample the 1D gradient strip texture with manual linear interpolation.
	origin := imageSrc0Origin()
	size := imageSrc0Size()

	// Map t to texel coordinate in [0, size.x-1].
	fx := t * (size.x - 1.0)
	ix := floor(fx)
	frac := fx - ix

	// Sample two adjacent texels and blend.
	c0 := imageSrc0At(origin + vec2(ix+0.5, 0.5))
	c1 := imageSrc0At(origin + vec2(min(ix+1.5, size.x-0.5), 0.5))

	return mix(c0, c1, frac)
}
